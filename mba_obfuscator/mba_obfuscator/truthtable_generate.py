#!/usr/bin/python3

"""
truth table generation methods:
    one method: brute force 
        step1: enumerate all possible bitwise expression.
        step2: select one set of bitwise expression and related truth table from the consideable bitwise expressions.
    another one method: recursive solution
        step1: read the entire truth table on n-variable from the file.
        step2: construct one bitwise expression on (n+1)-variable, let (n+1)_th variable is x,
                b_(n+1) = (b_n1 & ~x) | (b_n2 & x)
        step3: construct the entire truth table on (n+1)-variable.

Given the complexity of computation and storage,
the computation complexity is O(2**(2**n)),
the storage complexity is O(2**(2**n) * 2**n),
the truth table of 2-variable and 3-variable is generated by brute force,
the truth table of 4-variable is generated by recursive solution.
The generation of 5 or more variable on truth table is not practical
since the space complexity.
"""

import ast
import astunparse
import numpy as np
import re
import sympy
import sys
sys.path.append("../tools")
import time
import traceback
import z3
from mba_string_operation import truthtable_bitwise


def gen_1variable_truthtable(vnumber=1):
    """Entire truth table on 2-variable generation.
    Args:
        vnumber: the maximum number of variables in one bitwise expression.
    Returns:
        None.
    Raises:
        None.
    """
    assert vnumber==1, "This function can only generate 1-variable bitwise expression!"

    truthtableList = []
    truthtableList.append(["(x&~x)", truthtable_bitwise("(x&~x)", vnumber)])
    truthtableList.append(["~x", truthtable_bitwise("~x", vnumber)])
    truthtableList.append(["x", truthtable_bitwise("x",vnumber)])
    truthtableList.append(["~(x&~x)", truthtable_bitwise("~(x&~x)", vnumber)])

    output_truthtable(truthtableList, vnumber)

    return None


def gen_2variable_truthtable(vnumber=2):
    """Entire truth table on 2-variable generation.
    Args:
        vnumber: the maximum number of variables in one bitwise expression.
    Returns:
        None.
    Raises:
        None.
    """
    assert vnumber==2, "This function can only generate 2-variable bitwise expression!"
    #operators and variable names
    binaryOperator = ["&", "|", "^"]
    unaryOperator = ["", "~"]
    xVariable = ["x", "~x"]
    yVariable = ["y", "~y"]
    #bitwise expression on 1-variable
    variable = xVariable + yVariable

    expreStrList = []
    #bitwise expression on 2-variable 
    for xitem in variable:
        for bitem in binaryOperator:
            for yitem in variable:
                if xitem == yitem:
                    continue
                else:
                    expreStr1 = "(" + xitem + bitem + yitem + ")"
                    for uitem in unaryOperator:
                        if uitem:
                            expreStr2 = uitem + expreStr1 
                            expreStrList.append(expreStr2)
                        else:
                            expreStrList.append(expreStr1)

    #all building bitwise expression
    expreStrList = variable + expreStrList
    #bitwise expression and related truth table
    expreStrList = [[item, truthtable_bitwise(item, vnumber=vnumber)] for item in expreStrList]

    #refine and get entire bitwise expression and related truth table
    truthtableList = [None] * 2**(2**vnumber)
    for (i, item) in enumerate(expreStrList):
        truthtable = item[1]
        res = 0
        for j in range(len(truthtable)):
            res += truthtable[j] * 2**j
        if not truthtableList[res]:
            truthtableList[res] = item
        else:
            continue

    #assert len(truthtableList) == 2**(2**vnumber), "generate 2-variable truth table wrongly!"

    output_truthtable(truthtableList, vnumber)

    return None


def output_truthtable(truthtableList, vnumber):
    """output the entire truth table into file.
    Args:
        truthtableList: the list of truthtable and related bitwise expression.
        vnumver: the number of variables in one bitwise expression.
    """
    filename = "../dataset/{vnumber}variable_truthtable.txt".format(vnumber=vnumber)
    with open(filename, "wt") as fw:
        truthtable = None
        bitwiseExpre = None
        print("#truth_table, bitwiseExpression", file=fw)
        for item in truthtableList:
            if item:
                truthtable = item[1]
                truthtable = np.array(truthtable)
                bitwiseExpre = item[0]
                print(truthtable, bitwiseExpre, sep=",", file=fw)
            else:
                print("empth entry in truth table, unable to output to file")
                traceback.print_stack()
                sys.exit(0)


    return None



def gen_3variable_truthtable(vnumber=3):
    """entire truth table on 3-variable generation.
    Args:
        vnumber: maximum number of variable in one bitwise expression.
    Returns:
        None.
    Raises:
        None.
    """
    assert vnumber==3, "This function can only generate 3-variable bitwise expression!"
    #operators and variable names
    binaryOperator = ["&", "|", "^"]
    unaryOperator = ["", "~"]
    xVariable = ["x", "~x"]
    yVariable = ["y", "~y"]
    zVariable = ["z", "~z"]
    variable = xVariable + yVariable + zVariable

    bitList2variable = []
    #bitwise expression containing 2-variable 
    for xitem in variable:
        for bitem in binaryOperator:
            for yitem in variable:
                if xitem == yitem:
                    continue
                else:
                    expreStr1 = "(" + xitem + bitem + yitem + ")"
                    for uitem in unaryOperator:
                        if uitem:
                            expreStr2 = uitem + expreStr1
                            bitList2variable.append(expreStr2)
                        else:
                            bitList2variable.append(expreStr1)
    bitList3variable = []
    #bitwise expression containing 3-variable
    for zitem in zVariable:
        for bitem1 in binaryOperator:
            for yitem in yVariable:
                expreStr1 = "(" + yitem + bitem1 + zitem + ")"
                for uitem1 in unaryOperator:
                    if uitem1:
                        expreStr2 =  uitem1 + expreStr1
                    else:
                        expreStr2 = expreStr1
                    for bitem2 in binaryOperator:
                        for xitem in xVariable:
                            expreStr3 = "(" + xitem + bitem2 + expreStr2 + ")"
                            for uitem2 in unaryOperator:
                                if uitem2:
                                    expreStr4 = uitem2 + expreStr3 
                                    bitList3variable.append(expreStr4)
                                else:
                                    bitList3variable.append(expreStr3)

    #bitwise expression that doesn't contain deplicated variable
    expreStrList = variable + bitList2variable + bitList3variable
    expreStrList = [[item, truthtable_bitwise(item, vnumber=3)] for item in expreStrList]
    #refine and get entire bitwise expression and related truth table
    truthtableList = [None] * 2**(2**vnumber)
    termList = []
    for (i, item) in enumerate(expreStrList):
        truthtable = item[1]
        res = 0
        for j in range(len(truthtable)):
            res += truthtable[j] * 2**j
        if not truthtableList[res]:
            truthtableList[res] = item
            termList.append(item[0])
        else:
            continue

    bitListmore3variable = []
    #bitwise expression containing more 3-variable
    for xitem in termList:
        for yitem in termList:
            if xitem == yitem:
                continue
            else:
                for bitem in binaryOperator:
                    bitExpre = "(" + xitem + bitem + yitem + ")"
                    bitListmore3variable.append(bitExpre)
    #process the entire bitwise expression
    bitListmore3variable = [[item, truthtable_bitwise(item, vnumber=vnumber)] for item in bitListmore3variable]
    for (i, item) in enumerate(bitListmore3variable):
        truthtable = item[1]
        res = 0
        for j in range(len(truthtable)):
            res += truthtable[j] * 2**j
        if not truthtableList[res]:
            truthtableList[res] = item
            termList.append(item[0])
        else:
            continue
                    
    #assert len(truthtableList) == 2**(2**vnumber), "generate 3-variable truth table wrongly!"

    output_truthtable(truthtableList, vnumber)

    return None


def gen_4variable_truthtable(vnumber=4):
    """entire truth table on 4-variable generation.
    Args:
        vnumber: maximum number of variable in one bitwise expression.
    Returns:
        None.
    Raises:
        None.
    """
    assert vnumber==4, "This function can only generate 4-variable bitwise expression!"
    #operators and variable names
    binaryOperator = ["&", "|", "^"]
    unaryOperator = ["", "~"]
    xVariable = ["x", "~x"]
    yVariable = ["y", "~y"]
    zVariable = ["z", "~z"]
    tVariable = ["t", "~t"]
    variable = xVariable + yVariable + zVariable + tVariable

    bitList2variable = []
    #bitwise expression containing 2-variable 
    for xitem in variable:
        for bitem in binaryOperator:
            for yitem in variable:
                if xitem == yitem:
                    continue
                else:
                    expreStr1 = "(" + xitem + bitem + yitem + ")"
                    for uitem in unaryOperator:
                        if uitem:
                            expreStr2 = uitem + expreStr1
                            bitList2variable.append(expreStr2)
                        else:
                            bitList2variable.append(expreStr1)
    bitList3variable = []
    #bitwise expression containing 3-variable
    for xitem in variable:
        for bitem1 in binaryOperator:
            for yitem in variable:
                if xitem == yitem:
                    continue
                else:
                    expreStr1 = "(" + xitem + bitem1 + yitem + ")"
                    for uitem1 in unaryOperator:
                        if uitem1:
                            expreStr1 = uitem1 + expreStr1
                        for zitem in variable:
                            if zitem in [xitem, yitem]:
                                continue
                            else:
                                for bitem2 in binaryOperator:
                                    expreStr2 = "(" + expreStr1 + bitem2 + zitem + ")"
                                    for uitem2 in unaryOperator:
                                        if uitem2:
                                            expreStr2 = uitem2 + expreStr2
                                            bitList3variable.append(expreStr2)
                                        else:
                                            bitList3variable.append(expreStr2)

    bitList4variable = []
    #bitwise expression containing 4-variable
    for titem in tVariable:
        for bitem1 in binaryOperator:
            for zitem in zVariable:
                expreStr1 = "(" + zitem + bitem1 + titem + ")"
                for uitem1 in unaryOperator:
                    if uitem1:
                        expreStr2 =  uitem1 + expreStr1
                    else:
                        expreStr2 = expreStr1
                    for bitem2 in binaryOperator:
                        for yitem in yVariable:
                            expreStr3 = "(" + yitem + bitem2 + expreStr2 + ")"
                            for uitem2 in unaryOperator:
                                if uitem2:
                                    expreStr4 = uitem2 + expreStr3 
                                else:
                                    expreStr4 = expreStr3
                                for bitem3 in binaryOperator:
                                    for xitem in xVariable:
                                        expreStr5 = "(" + xitem + bitem3 + expreStr4 + ")"
                                        for uitem3 in unaryOperator:
                                            if uitem3:
                                                expreStr5 = uitem3 + expreStr5
                                                bitList4variable.append(expreStr5)
                                            else:
                                                bitList4variable.append(expreStr5)


    #bitwise expression that doesn't contain deplicated variable
    expreStrList = variable + bitList2variable + bitList3variable + bitList4variable
    expreStrList = [[bitExpre, truthtable_bitwise(bitExpre, vnumber=vnumber)] for bitExpre in expreStrList]
    #refine and get existing bitwise expression and related truth table
    truthtableList = [None] * 2**(2**vnumber)
    for (i, item) in enumerate(expreStrList):
        truthtable = item[1]
        res = 0
        for j in range(len(truthtable)):
            res += truthtable[j] * 2**j
        if not truthtableList[res]:
            truthtableList[res] = item
        else:
            continue
    #get the remaining bitwise expression and related truth table
    lastTruthDict = truthtable2dict(vnumber - 1)
    for (idx, itemList) in enumerate(truthtableList):
        if itemList:
            continue
        item = generate_one_new_bitwise_expression(idx, vnumber, "t", lastTruthDict)
        #one tip can save half time to get the entire truth table
        #truthtableList[2**vnumber - 1 - idx] = [truthValue, "~" + item[1]]
        truthtableList[idx] = item

                    
    #assert len(truthtableList) == 2**(2**vnumber), "generate 4-variable truth table wrongly!"

    output_truthtable(truthtableList, vnumber)

    return None


        
def generate_one_new_bitwise_expression(truthValue, vnumber, freevariable, lastTruthDict=None):
    """based on the value of truth table, generate one new bitwise expression.
    Args:
        truthValue: the value on the truth table.
        vnumber: the number of variables in one bitwise expression.
        freevariable: the new variable added into the generated bitwise expression.
        lastTruthDict: the last one entire truth table dictionary.
    Returns;
        term: one pair, truth table and related bitwise expression.
    """
    if not lastTruthDict:
        lastTruthDict = truthtable2dict(vnumber - 1)

    #construct the truth table
    truthtableStr = "0" * 2**vnumber + bin(truthValue)[2:]
    truthtableStr = truthtableStr[::-1][:2**vnumber]
    #split the truth table in the middle
    truthtablepreStr = truthtableStr[:2**(vnumber - 1)]
    truthtablepostStr = truthtableStr[2**(vnumber - 1):]
    prevalue = 0
    postvalue = 0
    for (ix, char) in enumerate(truthtablepreStr):
        prevalue += 2**ix * int(char)
    for (ix, char) in enumerate(truthtablepostStr):
        postvalue += 2**ix * int(char)
    #concatenate the new bitwise expression
    prebitExpre = lastTruthDict[prevalue]
    postbitExpre = lastTruthDict[postvalue]
    bitExpre = "(({pre}&~{fv})|({post}&{fv}))".format(pre=prebitExpre, post=postbitExpre, fv=freevariable)
    #construct the truth table
    truthList = truthtable_bitwise(bitExpre, vnumber=vnumber)
    item = [bitExpre, truthList]

    return item




def truthtable2dict(vnumber):
    """read the truth table from a file, build one related dictionary.
    Args:
        vnumber: the number of variables on the last truth table.
    Returns:
        truthDict: one dictionary on the truth table,
                    key: the integer value of the truth table,
                    value: the related bitwise expression of a truth table.
    """
    filename = "{vnumber}variable_truthtable.txt".format(vnumber=vnumber)
    truthDict = {}
    with open(filename, "r") as fr:
        for line in fr:
            if "#" not in line:
                line = line.strip()
                itemList = re.split(",", line)
                truthtable = itemList[0][1:-1].replace(" ", "")
                bitExpre= itemList[1]
                key = 0
                for (idx, char) in enumerate(truthtable):
                    key += 2**idx * int(char)
                truthDict[key] = bitExpre

    #assert len(truthDict) == 2**(2**vnumber), "read the last one containing truth table occurs error!"

    return truthDict


def check_truthtable(vnumber):
    """check the correctness of generated entire truth table.
    Args:
        vnumber: the number of variable in a expression.
    """
    filename = "{vnumber}variable_truthtable.txt".format(vnumber=vnumber)
    checkNumber = 0
    with open(filename, "r") as fr:
        for line in fr:
            if "#" not in line:
                line = line.strip()
                itemList = re.split(",", line)
                truthtable = itemList[0][1:-1].replace(" ", "")
                bitExpre= itemList[1]
                #generate the value of the truth table in the file
                value1 = 0
                for (idx, char) in enumerate(truthtable):
                    value1 += 2**idx * int(char)
                #generate the value of the related bitwise expression in the file
                truthList = truthtable_bitwise(bitExpre, vnumber)
                value2 = 0
                for (idx, v) in enumerate(truthList):
                    value2 += 2**idx * v
                #check the correctness of the truth table and bitwise expression
                if (value1 == checkNumber) and (checkNumber == value2):
                    checkNumber += 1
                else:
                    return False

    #assert countEntry == 2**(2**vnumber), "the {vnumber}variable truth table generation fails!".format(vnumber=vnumber)

    return True


def unittest():
    """unit test of this module, containing time complexity and cottectness checking.
    """
    start = time.time()
    gen_2variable_truthtable()
    elapsed = time.time() - start
    print("2-variable truth table generation costs time: ", elapsed)
    start = time.time()
    gen_3variable_truthtable()
    elapsed = time.time() - start
    print("3-variable truth table generation costs time: ", elapsed)
    start = time.time()
    gen_4variable_truthtable()
    elapsed = time.time() - start
    print("4-variable truth table generation costs time: ", elapsed)
    res2variable = check_truthtable(2)
    print("check the generation of 2-variable truth table:", res2variable)
    res3variable = check_truthtable(3)
    print("check the generation of 3-variable truth table:", res3variable)
    res4variable = check_truthtable(4)
    print("check the generation of 4-variable truth table:", res4variable)


def exe_all():
    gen_1variable_truthtable()
    gen_2variable_truthtable()
    gen_3variable_truthtable()
    gen_4variable_truthtable()


def main():
    exe_all()


if __name__ == "__main__":
    #unittest()
    main()



